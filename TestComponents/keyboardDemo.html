<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Canvas Piano Keyboard</title>
    <style>
        /* General styling for the page */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars on the body itself */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex; /* Use flexbox for the main layout */
        }

        /* Main container for the application demo */
        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: #ffffff;
            /* No fixed size or resize handle; it fills the body */
        }

        /* Header section with title and controls */
        .header {
            flex-shrink: 0; /* Prevent the header from shrinking */
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            background-color: #fff;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #111827;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* Styling for the MIDI output selector */
        #midi-outputs {
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background-color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        #midi-outputs:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        
        /* Wrapper for the canvas to make it fill remaining space */
        .canvas-wrapper {
            flex-grow: 1; /* This makes the wrapper fill all available vertical space */
            position: relative; /* Needed for the absolutely positioned canvas */
            min-height: 0; /* A flexbox hack to prevent overflow issues */
        }

        /* Canvas where the piano is rendered */
        #piano-keyboard-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="header">
            <h1>Piano Keyboard</h1>
            <div class="controls">
                <label for="midi-outputs">MIDI Output:</label>
                <select id="midi-outputs">
                    <option value="">No devices found</option>
                </select>
            </div>
        </div>
        <div class="canvas-wrapper">
            <canvas id="piano-keyboard-canvas"></canvas>
        </div>
    </div>

    <script>
    /**
     * UI Control Components
     * These classes define the interactive UI elements within the settings drawer.
     */
    class SliderControl {
        constructor(config) {
            this.ctx = config.ctx;
            this.label = config.label;
            this.x = config.x;
            this.y = config.y;
            this.width = config.width || 100;
            this.height = 24;
            this.min = config.min || 0;
            this.max = config.max || 127;
            this.value = config.initialValue;
            this.font = config.font || '12px sans-serif';
        }

        getBounds() {
            const trackHeight = 6, handleWidth = 12;
            const trackX = this.x, trackY = this.y + this.height / 2 - trackHeight / 2;
            const handleX = trackX + ((this.value - this.min) / (this.max - this.min)) * this.width - (handleWidth / 2);
            const handleY = this.y;
            return {
                track: { x: trackX, y: trackY, width: this.width, height: trackHeight },
                handle: { x: handleX, y: handleY, width: handleWidth, height: this.height }
            };
        }

        draw() {
            const bounds = this.getBounds();
            this.ctx.save();
            this.ctx.font = this.font;
            this.ctx.fillStyle = '#333';
            this.ctx.textAlign = 'left';
            this.ctx.fillText(this.label, bounds.track.x, bounds.track.y - 10);
            this.ctx.fillStyle = '#a0a0a0';
            this.ctx.beginPath();
            this.ctx.roundRect(bounds.track.x, bounds.track.y, bounds.track.width, bounds.track.height, 3);
            this.ctx.fill();
            this.ctx.fillStyle = '#3b82f6';
            this.ctx.strokeStyle = '#2563eb';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.roundRect(bounds.handle.x, bounds.handle.y, bounds.handle.width, bounds.handle.height, 4);
            this.ctx.fill();
            this.ctx.stroke();
            this.ctx.textAlign = 'right';
            this.ctx.fillText(this.value, bounds.track.x + bounds.track.width, bounds.track.y - 10);
            this.ctx.restore();
        }

        updateValueFromPosition(x) {
            const bounds = this.getBounds();
            const relativeX = x - bounds.track.x;
            const ratio = Math.max(0, Math.min(1, relativeX / bounds.track.width));
            this.value = Math.round(this.min + ratio * (this.max - this.min));
        }

        isPointOnControl(x, y) {
            const bounds = this.getBounds();
            const interactiveArea = { x: bounds.track.x, y: bounds.handle.y, width: bounds.track.width, height: bounds.handle.height };
            return x >= interactiveArea.x && x <= interactiveArea.x + interactiveArea.width && y >= interactiveArea.y && y <= interactiveArea.y + interactiveArea.height;
        }
    }

    class ToggleSwitch {
        constructor(config) {
            this.ctx = config.ctx;
            this.label = config.label;
            this.x = config.x;
            this.y = config.y;
            this.width = 40;
            this.height = 20;
            this.value = config.initialValue || false;
            this.font = config.font || '12px sans-serif';
        }

        getBounds() {
            return { x: this.x, y: this.y, width: this.width, height: this.height };
        }

        getFullWidth() {
            const labelWidth = this.ctx.measureText(this.label).width;
            return this.width + 10 + labelWidth; // 10 is padding
        }

        draw() {
            const bounds = this.getBounds();
            this.ctx.save();
            this.ctx.font = this.font;
            this.ctx.fillStyle = '#333';
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(this.label, bounds.x + bounds.width + 10, bounds.y + bounds.height / 2);
            
            this.ctx.fillStyle = this.value ? '#3b82f6' : '#a0a0a0';
            this.ctx.beginPath();
            this.ctx.roundRect(bounds.x, bounds.y, bounds.width, bounds.height, this.height / 2);
            this.ctx.fill();

            const handleRadius = this.height / 2 - 2;
            const handleX = this.value ? bounds.x + bounds.width - handleRadius - 2 : bounds.x + handleRadius + 2;
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(handleX, bounds.y + this.height / 2, handleRadius, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        }

        toggle() { this.value = !this.value; }

        isPointOnControl(x, y) {
            const fullWidth = this.getFullWidth();
            const bounds = this.getBounds();
            return x >= bounds.x && x <= bounds.x + fullWidth && y >= bounds.y && y <= bounds.y + bounds.height;
        }
    }

    /**
     * Drawer Component
     * Encapsulates all logic for the settings drawer.
     */
    class Drawer {
        constructor(config) {
            this.ctx = config.ctx;
            this.tabs = config.tabs;
            this.onControlChange = config.onControlChange;
            this.onSettingsSave = config.onSettingsSave;
            this.canvas = this.ctx.canvas;

            // State
            this.isOpen = false;
            this.scrollOffsetX = 0;
            this.scrollOffsetY = 0;
            this.activeTab = Object.keys(this.tabs)[0] || '';
            this.calculatedHeight = config.handleHeight;
            this.targetHeight = config.handleHeight;
            this.isAnimating = false;
            this.activeTouches = new Map();
            
            // Constants
            this.HANDLE_HEIGHT = config.handleHeight;
            this.TAB_HEIGHT = config.tabHeight;
            this.CONTROL_PADDING = { x: 20, y: 20 };
            this.CONTROL_SPACING = { x: 40, y: 15 };
        }

        // --- Public API for PianoKeyboard ---
        getHeight() { return this.calculatedHeight; }
        
        toggle() {
            this.isOpen = !this.isOpen;
            this.updateHeight();
        }

        isAnimating() { return this.isAnimating; }

        isPointInBounds(x, y) {
            return y < this.calculatedHeight;
        }

        isPointInHandle(x, y) {
            return this.isPointInRect(x, y, this.getHandleBounds());
        }

        // --- Event Handling ---
        handlePointerDown(x, y, id) {
             if (isNaN(this.scrollOffsetY)) { this.scrollOffsetY = 0; }
             if (isNaN(this.scrollOffsetX)) { this.scrollOffsetX = 0; }

            const pointerXInDrawer = x + this.scrollOffsetX;
            const pointerYInDrawer = y + this.scrollOffsetY;
            
            const tabBounds = this.getTabBounds();
            for (const tabName in tabBounds) {
                if (this.isPointInRect(pointerXInDrawer, pointerYInDrawer, tabBounds[tabName])) {
                    if (this.activeTab !== tabName) {
                        this.activeTab = tabName;
                        this.updateHeight();
                    }
                    return;
                }
            }

            for (const control of this.tabs[this.activeTab].controls) {
                if (control.isPointOnControl(pointerXInDrawer, pointerYInDrawer)) {
                    if (control instanceof ToggleSwitch) {
                        control.toggle();
                        this.onControlChange();
                        this.onSettingsSave();
                    } else {
                        this.activeTouches.set(id, { type: 'drawerControl', control: control });
                        control.updateValueFromPosition(pointerXInDrawer);
                        this.onControlChange();
                    }
                    return;
                }
            }
            
            this.activeTouches.set(id, { type: 'drawerPan', lastX: x, lastY: y });
        }

        handlePointerMove(x, y, id) {
            const activeTouch = this.activeTouches.get(id);
            if (!activeTouch) return;

            switch(activeTouch.type) {
                case 'drawerControl':
                    const pointerXInDrawer = x + this.scrollOffsetX;
                    activeTouch.control.updateValueFromPosition(pointerXInDrawer);
                    this.onControlChange();
                    break;
                case 'drawerPan':
                    const dx = x - activeTouch.lastX;
                    const dy = y - activeTouch.lastY;
                    this.scrollOffsetX -= dx;
                    this.scrollOffsetY -= dy;
                    this.clampScroll();
                    activeTouch.lastX = x;
                    activeTouch.lastY = y;
                    break;
            }
        }

        handlePointerUp(id) {
            const activeTouch = this.activeTouches.get(id);
            if (activeTouch && activeTouch.type === 'drawerControl') {
                this.onSettingsSave();
            }
            this.activeTouches.delete(id);
        }

        // --- Drawing and Layout ---
        draw() {
            const drawerContentHeight = this.calculatedHeight - this.HANDLE_HEIGHT;
            
            this.ctx.save();
            this.ctx.fillStyle = '#e0e0e0';
            this.ctx.fillRect(0, 0, this.canvas.width, this.calculatedHeight);
            
            if (drawerContentHeight > 0) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(0, 0, this.canvas.width, drawerContentHeight);
                this.ctx.clip();
                this.ctx.translate(-this.scrollOffsetX, -this.scrollOffsetY);
                this.drawTabs();
                this.drawControls();
                this.ctx.restore();
            }
            
            this.drawScrollbars();
            this.drawHandle();
            this.ctx.restore();
        }

        drawTabs() {
            this.ctx.save();
            this.ctx.font = '14px sans-serif';
            this.ctx.textBaseline = 'middle';
            let xPos = 10;
            for(const tabName in this.tabs) {
                const isActive = tabName === this.activeTab;
                this.ctx.fillStyle = isActive ? '#d0d0d0' : '#e0e0e0';
                const textMetrics = this.ctx.measureText(tabName);
                const tabWidth = textMetrics.width + 20;
                this.ctx.fillRect(xPos, 0, tabWidth, this.TAB_HEIGHT);
                this.ctx.fillStyle = isActive ? '#000' : '#555';
                this.ctx.fillText(tabName, xPos + 10, this.TAB_HEIGHT / 2);
                xPos += tabWidth;
            }
            this.ctx.strokeStyle = '#b0b0b0';
            this.ctx.beginPath();
            this.ctx.moveTo(0, this.TAB_HEIGHT - 1);
            this.ctx.lineTo(this.getContentWidth(), this.TAB_HEIGHT - 1);
            this.ctx.stroke();
            this.ctx.restore();
        }

        drawControls() {
            const controls = this.tabs[this.activeTab].controls;
            this.layoutControls(controls);
            controls.forEach(control => control.draw());
        }
        
        drawHandle() {
            const bounds = this.getHandleBounds();
            this.ctx.save();
            this.ctx.fillStyle = '#b0b0b0';
            this.ctx.beginPath();
            this.ctx.roundRect(bounds.x, bounds.y, bounds.width, bounds.height, [this.isOpen ? 0 : 10, this.isOpen ? 0 : 10, 10, 10]);
            this.ctx.fill();
            this.ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            this.ctx.lineWidth = 1.5;
            const handleCenterY = bounds.y + bounds.height / 2;
            this.ctx.beginPath();
            this.ctx.moveTo(bounds.x + 20, handleCenterY - 3);
            this.ctx.lineTo(bounds.x + bounds.width - 20, handleCenterY - 3);
            this.ctx.moveTo(bounds.x + 20, handleCenterY + 3);
            this.ctx.lineTo(bounds.x + bounds.width - 20, handleCenterY + 3);
            this.ctx.stroke();
            this.ctx.restore();
        }
        
        drawScrollbars() {
            if (!this.isOpen) return;
            const visibleWidth = this.canvas.width;
            const visibleHeight = this.calculatedHeight - this.HANDLE_HEIGHT;
            const totalContentWidth = this.getContentWidth();
            const totalContentHeight = this.getContentHeight();
            const scrollbarSize = 10;

            this.ctx.save();
            this.ctx.translate(this.scrollOffsetX, this.scrollOffsetY);

            if (totalContentHeight > visibleHeight) {
                const trackHeight = visibleHeight - scrollbarSize;
                const handleHeight = Math.max(20, (visibleHeight / totalContentHeight) * trackHeight);
                const maxScroll = totalContentHeight - visibleHeight;
                const handleY = (this.scrollOffsetY / maxScroll) * (trackHeight - handleHeight);
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                this.ctx.fillRect(visibleWidth - scrollbarSize, 0, scrollbarSize, trackHeight);
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(visibleWidth - scrollbarSize, handleY, scrollbarSize, handleHeight);
            }

            if (totalContentWidth > visibleWidth) {
                const trackWidth = visibleWidth - scrollbarSize;
                const handleWidth = Math.max(20, (visibleWidth / totalContentWidth) * trackWidth);
                const maxScroll = totalContentWidth - visibleWidth;
                const handleX = (this.scrollOffsetX / maxScroll) * (trackWidth - handleWidth);
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                this.ctx.fillRect(0, visibleHeight - scrollbarSize, trackWidth, scrollbarSize);
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(handleX, visibleHeight - scrollbarSize, handleWidth, scrollbarSize);
            }
            this.ctx.restore();
        }

        // --- Helpers and Calculations ---
        layoutControls(controls) {
            let xPos = this.CONTROL_PADDING.x;
            let yPos = this.TAB_HEIGHT + this.CONTROL_PADDING.y;
            for (const control of controls) {
                control.x = xPos;
                control.y = yPos;
                
                let controlWidth = 0;
                if (control instanceof ToggleSwitch) {
                    controlWidth = control.getFullWidth();
                } else { // SliderControl
                    controlWidth = control.width;
                }
                xPos += controlWidth + this.CONTROL_SPACING.x;
            }
        }

        getTabBounds() {
            const bounds = {};
            this.ctx.save();
            this.ctx.font = '14px sans-serif';
            let xPos = 10;
            for(const tabName in this.tabs) {
                const textMetrics = this.ctx.measureText(tabName);
                const tabWidth = textMetrics.width + 20;
                bounds[tabName] = { x: xPos, y: 0, width: tabWidth, height: this.TAB_HEIGHT };
                xPos += tabWidth;
            }
            this.ctx.restore();
            return bounds;
        }

        getHandleBounds() {
            const handleWidth = 100;
            const y = this.calculatedHeight - this.HANDLE_HEIGHT;
            return { x: this.canvas.width / 2 - handleWidth / 2, y, width: handleWidth, height: this.HANDLE_HEIGHT };
        }
        
        getContentWidth() {
            const controls = this.tabs[this.activeTab].controls;
            if (controls.length === 0) return this.canvas.width;
            this.layoutControls(controls);
            const lastControl = controls[controls.length - 1];
            let lastControlWidth = 0;
            if (lastControl instanceof ToggleSwitch) {
                lastControlWidth = lastControl.getFullWidth();
            } else {
                lastControlWidth = lastControl.width;
            }
            return lastControl.x + lastControlWidth + this.CONTROL_PADDING.x;
        }

        getContentHeight() {
            const controls = this.tabs[this.activeTab].controls;
            if (controls.length === 0) return this.TAB_HEIGHT + this.CONTROL_PADDING.y;
            this.layoutControls(controls);
            const firstControl = controls[0];
            return firstControl.y + firstControl.height + this.CONTROL_PADDING.y;
        }

        clampScroll() {
            const visibleHeight = this.calculatedHeight - this.HANDLE_HEIGHT;
            const maxScrollY = Math.max(0, this.getContentHeight() - visibleHeight);
            this.scrollOffsetY = Math.max(0, Math.min(this.scrollOffsetY, maxScrollY));
            
            const visibleWidth = this.canvas.width;
            const maxScrollX = Math.max(0, this.getContentWidth() - visibleWidth);
            this.scrollOffsetX = Math.max(0, Math.min(this.scrollOffsetX, maxScrollX));
        }

        updateHeight(animate = true) {
            if (this.isOpen) {
                const contentHeight = this.getContentHeight();
                const maxDrawerHeight = this.canvas.height * 0.5;
                this.targetHeight = Math.min(contentHeight, maxDrawerHeight) + this.HANDLE_HEIGHT;
            } else {
                this.targetHeight = this.HANDLE_HEIGHT;
            }
            this.clampScroll();
            if (animate && !this.isAnimating) {
                this.animate();
            } else {
                this.calculatedHeight = this.targetHeight;
            }
        }

        animate() {
            this.isAnimating = true;
            const diff = this.targetHeight - this.calculatedHeight;
            if (Math.abs(diff) < 1) {
                this.calculatedHeight = this.targetHeight;
                this.isAnimating = false;
                return;
            }
            this.calculatedHeight += diff * 0.2;
            requestAnimationFrame(this.animate.bind(this));
        }

        isPointInRect(x, y, rect) {
            return rect && x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
        }
    }

    /**
     * PianoKeyboard Component
     */
    class PianoKeyboard {
        constructor(config) {
            this.canvas = config.canvas;
            this.ctx = this.canvas.getContext('2d');
            this.midiCallback = config.midiCallback;
            this.customKeyMappings = config.customKeyMappings || [];
            this.onSettingsChange = config.onSettingsChange || (() => {});
            this.canvasId = this.canvas.id || 'piano-keyboard-default';

            // --- State ---
            this.keys = [];
            this.activeTouches = new Map();
            this.computerKeysDown = new Set();
            this.scrollOffset = 0;
            this.octaveOffset = 0;
            this.keyHeight = 0;
            
            // --- Settings & Controls ---
            this.settings = { volume: 100, minVelocity: 0, maxVelocity: 127, pitchBend: false, velocityByPos: false };
            this.volumeSlider = new SliderControl({ ctx: this.ctx, label: 'Volume', initialValue: this.settings.volume, width: 100 });
            this.minVelocitySlider = new SliderControl({ ctx: this.ctx, label: 'Min', initialValue: this.settings.minVelocity, width: 100 });
            this.maxVelocitySlider = new SliderControl({ ctx: this.ctx, label: 'Max', initialValue: this.settings.maxVelocity, width: 100 });
            this.pitchBendToggle = new ToggleSwitch({ ctx: this.ctx, label: 'Drag for Pitch Bend', initialValue: this.settings.pitchBend });
            this.velocityByPosToggle = new ToggleSwitch({ ctx: this.ctx, label: 'Lower on Keys Is Louder', initialValue: this.settings.velocityByPos });
            
            const tabs = {
                'Volume': { controls: [this.volumeSlider, this.minVelocitySlider, this.maxVelocitySlider] },
                'Keys': { controls: [this.pitchBendToggle, this.velocityByPosToggle] },
                'Scales': { controls: [] }
            };

            // --- Constants ---
            this.TOTAL_KEYS = 88;
            this.WHITE_KEYS_COUNT = 52;
            this.LOWEST_NOTE = 21;
            this.SCROLLBAR_HEIGHT = 20;
            this.WHITE_KEY_ASPECT_RATIO = 5.5; 
            this.BLACK_KEY_WIDTH_RATIO = 0.6;
            this.BLACK_KEY_HEIGHT_RATIO = 0.6;
            this.MAX_WHITE_KEY_WIDTH = 40;
            this.DRAWER_HANDLE_HEIGHT = 20;
            this.TAB_HEIGHT = 30;

            // --- Component Initialization ---
            this.drawer = new Drawer({
                ctx: this.ctx,
                tabs: tabs,
                onControlChange: this.updateSettingsFromControls.bind(this),
                onSettingsSave: this.saveSettings.bind(this),
                handleHeight: this.DRAWER_HANDLE_HEIGHT,
                tabHeight: this.TAB_HEIGHT,
            });

            this.initKeys();
            this.initEventListeners();
            this.loadSettings();
            this.resizeCanvas();
            this.animationLoop();
        }

        initKeys() {
            let whiteKeyIndex = 0;
            for (let i = 0; i < this.TOTAL_KEYS; i++) {
                const note = this.LOWEST_NOTE + i;
                const isBlack = [1, 3, 6, 8, 10].includes(note % 12);
                this.keys.push({ note, isBlack, isPressed: false, x: 0, y: 0, width: 0, height: 0, whiteKeyIndex: isBlack ? -1 : whiteKeyIndex++ });
            }
        }

        initEventListeners() {
            new ResizeObserver(() => this.resizeCanvas()).observe(this.canvas);
            this.canvas.addEventListener('mousedown', this.handlePointerDown.bind(this));
            window.addEventListener('mousemove', this.handlePointerMove.bind(this));
            window.addEventListener('mouseup', this.handlePointerUp.bind(this));
            this.canvas.addEventListener('touchstart', this.handlePointerDown.bind(this), { passive: false });
            window.addEventListener('touchmove', this.handlePointerMove.bind(this), { passive: false });
            window.addEventListener('touchend', this.handlePointerUp.bind(this));
            window.addEventListener('touchcancel', this.handlePointerUp.bind(this));
            window.addEventListener('keydown', this.handleKeyDown.bind(this));
            window.addEventListener('keyup', this.handleKeyUp.bind(this));
        }

        resizeCanvas() {
            if (this.canvas.width !== this.canvas.clientWidth || this.canvas.height !== this.canvas.clientHeight) {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.drawer.updateHeight(false);
            }
        }

        handlePointerDown(e) {
            e.preventDefault();
            const pointers = e.changedTouches ? e.changedTouches : [e];
            const rect = this.canvas.getBoundingClientRect();

            for (const pointer of pointers) {
                const x = pointer.clientX - rect.left;
                const y = pointer.clientY - rect.top;
                const id = pointer.identifier ?? 'mouse';
                
                if (this.drawer.isPointInHandle(x, y)) {
                    this.drawer.toggle();
                    continue;
                }

                if (this.drawer.isPointInBounds(x, y)) {
                    this.drawer.handlePointerDown(x, y, id);
                    continue;
                }

                if (this.isPointInRect(x, y, this.getScrollbarHandleBounds())) {
                    this.activeTouches.set(id, { type: 'scrollbar', startX: x - this.getScrollbarHandleBounds().x });
                    continue; 
                }

                const drawerHeight = this.drawer.getHeight();
                const panAreaTop = drawerHeight + this.keyHeight;
                const panAreaBottom = this.canvas.height - this.SCROLLBAR_HEIGHT;
                if (y > panAreaTop && y < panAreaBottom) {
                    this.activeTouches.set(id, { type: 'pan', lastX: x });
                    continue;
                }

                const key = this.getKeyAt(x, y);
                if (key) {
                    const relativeY = y - drawerHeight;
                    this.pressKey(key.note, relativeY);
                    this.activeTouches.set(id, { type: 'key', note: key.note, startX: x, startY: y, keyWidth: key.width });
                }
            }
        }

        handlePointerMove(e) {
            if (this.activeTouches.size === 0 && this.drawer.activeTouches.size === 0) return;
            e.preventDefault();
            const pointers = e.changedTouches ? e.changedTouches : [e];
            const rect = this.canvas.getBoundingClientRect();

            for (const pointer of pointers) {
                const x = pointer.clientX - rect.left;
                const y = pointer.clientY - rect.top;
                const id = pointer.identifier ?? 'mouse';
                
                if (this.drawer.activeTouches.has(id)) {
                    this.drawer.handlePointerMove(x, y, id);
                    continue;
                }

                const activeTouch = this.activeTouches.get(id);
                if (!activeTouch) continue;

                switch(activeTouch.type) {
                    case 'scrollbar':
                        const { totalWidth, handleWidth, trackWidth } = this.getScrollbarMetrics();
                        if (totalWidth <= this.canvas.width) return;
                        const newHandleX = x - activeTouch.startX;
                        const travelDist = trackWidth - handleWidth;
                        const scrollRatio = Math.max(0, Math.min(1, newHandleX / travelDist));
                        this.scrollOffset = scrollRatio * (totalWidth - this.canvas.width);
                        this.clampScrollOffset();
                        break;
                    case 'pan':
                        const panDx = x - activeTouch.lastX;
                        this.scrollOffset -= panDx;
                        this.clampScrollOffset();
                        activeTouch.lastX = x;
                        break;
                    case 'key':
                        if (this.settings.pitchBend) {
                            const bendDX = x - activeTouch.startX;
                            const bendRatio = Math.max(-1, Math.min(1, bendDX / activeTouch.keyWidth));
                            const bendValue = Math.round(8192 + bendRatio * 4096);
                            this.midiCallback([0xE0, bendValue & 0x7F, (bendValue >> 7) & 0x7F], 'internal');
                        } else {
                            const currentKey = this.getKeyAt(x, y);
                            if (currentKey && currentKey.note !== activeTouch.note) {
                                this.releaseKey(activeTouch.note);
                                const relativeY = y - this.drawer.getHeight();
                                this.pressKey(currentKey.note, relativeY);
                                this.activeTouches.set(id, { type: 'key', note: currentKey.note, startX: x, startY: y, keyWidth: currentKey.width });
                            } else if (!currentKey && y > this.drawer.getHeight()) {
                                this.releaseKey(activeTouch.note);
                                if (this.settings.pitchBend) this.midiCallback([0xE0, 0, 64], 'internal');
                                this.activeTouches.delete(id);
                            }
                        }
                        break;
                }
            }
        }

        handlePointerUp(e) {
            e.preventDefault();
            const pointers = e.changedTouches ? e.changedTouches : [e];
            for (const pointer of pointers) {
                const id = pointer.identifier ?? 'mouse';
                
                if (this.drawer.activeTouches.has(id)) {
                    this.drawer.handlePointerUp(id);
                }

                const activeTouch = this.activeTouches.get(id);
                if (activeTouch) {
                    if (activeTouch.type === 'key') {
                        this.releaseKey(activeTouch.note);
                        if (this.settings.pitchBend) this.midiCallback([0xE0, 0, 64], 'internal');
                    }
                    this.activeTouches.delete(id);
                }
            }
        }
        
        handleKeyDown(e) {
            if (e.repeat || this.computerKeysDown.has(e.code)) return;
            const keyMapping = this.getComputerKeyMapping();
            const noteInfo = keyMapping[e.code];
            if (noteInfo) {
                this.computerKeysDown.add(e.code);
                this.pressKey(noteInfo.note + (this.octaveOffset * 12));
            } else if (e.code === 'Comma') this.octaveOffset = Math.max(-4, this.octaveOffset - 1);
            else if (e.code === 'Period') this.octaveOffset = Math.min(4, this.octaveOffset + 1);
        }

        handleKeyUp(e) {
            const keyMapping = this.getComputerKeyMapping();
            const noteInfo = keyMapping[e.code];
            if (noteInfo) {
                this.computerKeysDown.delete(e.code);
                this.releaseKey(noteInfo.note + (this.octaveOffset * 12));
            }
        }
        
        getComputerKeyMapping() {
            const baseNote = 60;
            const mapping = {'KeyQ':{note:baseNote+0},'KeyW':{note:baseNote+2},'KeyE':{note:baseNote+4},'KeyR':{note:baseNote+5},'KeyT':{note:baseNote+7},'KeyY':{note:baseNote+9},'KeyU':{note:baseNote+11},'KeyI':{note:baseNote+12},'KeyO':{note:baseNote+14},'KeyP':{note:baseNote+16},'Digit2':{note:baseNote+1},'Digit3':{note:baseNote+3},'Digit5':{note:baseNote+6},'Digit6':{note:baseNote+8},'Digit7':{note:baseNote+10},'Digit9':{note:baseNote+13},'Digit0':{note:baseNote+15}};
            this.customKeyMappings.forEach(m => { mapping[m.code] = { note: m.note }; });
            return mapping;
        }

        pressKey(note, relativeY = null) {
            const key = this.keys.find(k => k.note === note);
            if (!key) return;

            key.isPressed = true;
            let velocity = this.settings.volume;

            if (this.settings.velocityByPos && relativeY !== null) {
                let posVelocity = 0;
                let ratio = 0;
                if (key.isBlack) {
                    ratio = Math.max(0, Math.min(1, relativeY / key.height));
                } else {
                    const whiteKeyVelocityTopY = key.height * this.BLACK_KEY_HEIGHT_RATIO;
                    if (relativeY > whiteKeyVelocityTopY) {
                        const velocityHeight = key.height - whiteKeyVelocityTopY;
                        const adjustedY = relativeY - whiteKeyVelocityTopY;
                        ratio = Math.max(0, Math.min(1, adjustedY / velocityHeight));
                    } else {
                        ratio = 0;
                    }
                }
                posVelocity = Math.round(ratio * 127);
                velocity = posVelocity;
            }
            
            velocity = Math.max(this.settings.minVelocity, Math.min(this.settings.maxVelocity, velocity));
            
            this.midiCallback([0x90, note, velocity], "internal");
        }

        releaseKey(note) {
            const key = this.keys.find(k => k.note === note);
            if (key) {
                key.isPressed = false;
                this.midiCallback([0x80, note, 0], "internal");
            }
        }

        handleExternalMidiMessage(message, deviceName) {
            const status = message[0], command = status & 0xF0;
            const newMessage = [...message];

            if (command === 0x90 || command === 0x80) {
                const note = message[1];
                let velocity = (message.length > 2) ? message[2] : 0;
                const key = this.keys.find(k => k.note === note);
                
                if (command === 0x90 && velocity > 0) {
                    if (key) key.isPressed = true;
                } else {
                    if (key) key.isPressed = false;
                }
            }
            this.midiCallback(newMessage, deviceName);
        }

        getKeyAt(x, y) {
            const drawerHeight = this.drawer.getHeight();
            if (y < drawerHeight || y > drawerHeight + this.keyHeight) return null;
            
            const adjustedY = y - drawerHeight;
            for (const key of this.keys.filter(k => k.isBlack).reverse()) {
                if (x >= key.x && x <= key.x + key.width && adjustedY >= key.y && adjustedY <= key.y + key.height) return key;
            }
            for (const key of this.keys.filter(k => !k.isBlack).reverse()) {
                if (x >= key.x && x <= key.x + key.width && adjustedY >= key.y && adjustedY <= key.y + key.height) return key;
            }
            return null;
        }

        animationLoop() {
            this.draw();
            requestAnimationFrame(this.animationLoop.bind(this));
        }

        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            const drawerHeight = this.drawer.getHeight();
            this.calculateKeyDimensions(drawerHeight);
            this.clampScrollOffset();
            
            this.drawer.draw();
            
            const keyBottomY = drawerHeight + this.keyHeight;
            const scrollbarTopY = this.canvas.height - this.SCROLLBAR_HEIGHT;
            if (keyBottomY < scrollbarTopY) {
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, keyBottomY, this.canvas.width, scrollbarTopY - keyBottomY);
            }

            if (this.keyHeight > 0) {
                this.ctx.save();
                this.ctx.translate(0, drawerHeight);
                this.keys.filter(k => !k.isBlack).forEach(key => this.drawWhiteKey(key));
                this.keys.filter(k => k.isBlack).forEach(key => this.drawBlackKey(key));
                this.ctx.restore();
            }
            this.drawScrollbar();
        }
        
        calculateKeyDimensions(drawerHeight) {
            const availableHeight = this.canvas.height - this.SCROLLBAR_HEIGHT - drawerHeight;
            if (availableHeight <= 0) {
                this.keyHeight = 0;
                this.keys.forEach(k => { k.width = k.height = 0; });
                return;
            }

            const widthFromHeight = availableHeight / this.WHITE_KEY_ASPECT_RATIO;
            const whiteKeyWidth = Math.min(widthFromHeight, this.MAX_WHITE_KEY_WIDTH);
            
            this.keyHeight = whiteKeyWidth * this.WHITE_KEY_ASPECT_RATIO;
            const blackKeyWidth = whiteKeyWidth * this.BLACK_KEY_WIDTH_RATIO;
            const blackKeyHeight = this.keyHeight * this.BLACK_KEY_HEIGHT_RATIO;

            this.keys.forEach(key => {
                if (!key.isBlack) {
                    key.width = whiteKeyWidth;
                    key.height = this.keyHeight;
                    key.x = key.whiteKeyIndex * whiteKeyWidth - this.scrollOffset;
                    key.y = 0;
                }
            });
            this.keys.forEach(key => {
                if (key.isBlack) {
                    const prevKey = this.keys[key.note - this.LOWEST_NOTE - 1];
                    key.width = blackKeyWidth;
                    key.height = blackKeyHeight;
                    key.x = prevKey.x + prevKey.width - (blackKeyWidth / 2);
                    key.y = 0;
                }
            });
        }

        clampScrollOffset() {
            const { totalWidth } = this.getScrollbarMetrics();
            const maxScroll = totalWidth - this.canvas.width;
            this.scrollOffset = Math.max(0, Math.min(this.scrollOffset, maxScroll > 0 ? maxScroll : 0));
        }

        drawWhiteKey(key) {
            if (key.x > this.canvas.width || key.x + key.width < 0) return;
            this.ctx.save();
            const cornerRadius = Math.min(6, key.width / 4, key.height / 8);
            this.ctx.beginPath();
            this.ctx.roundRect(key.x, key.y, key.width, key.height, [0, 0, cornerRadius, cornerRadius]);
            const grad = this.ctx.createLinearGradient(key.x, key.y, key.x + key.width, key.y);
            if (key.isPressed) { grad.addColorStop(0, '#a0c4ff'); grad.addColorStop(1, '#c0d8ff'); } 
            else { grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.8, '#f8f8f8'); grad.addColorStop(1, '#e8e8e8'); }
            this.ctx.fillStyle = grad;
            this.ctx.fill();
            this.ctx.strokeStyle = '#999';
            this.ctx.lineWidth = 1;
            this.ctx.stroke();
            this.ctx.restore();
        }

        drawBlackKey(key) {
            if (key.x > this.canvas.width || key.x + key.width < 0) return;
            this.ctx.save();
            const cornerRadius = Math.min(5, key.width / 4, key.height / 8);
            this.ctx.beginPath();
            this.ctx.roundRect(key.x, key.y, key.width, key.height, [0, 0, cornerRadius, cornerRadius]);
            const grad = this.ctx.createLinearGradient(key.x, key.y, key.x + key.width, key.y);
            if (key.isPressed) { grad.addColorStop(0, '#7b1fa2'); grad.addColorStop(1, '#5a0f82'); } 
            else { grad.addColorStop(0, '#4a4a4a'); grad.addColorStop(1, '#2a2a2a'); }
            this.ctx.fillStyle = grad;
            this.ctx.fill();
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            this.ctx.fillRect(key.x + 2, key.y + 2, key.width - 4, 2);
            this.ctx.restore();
        }
        
        isPointInRect(x, y, rect) {
            return rect && x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
        }

        getScrollbarMetrics() {
            const firstWhiteKey = this.keys.find(k => !k.isBlack);
            if (!firstWhiteKey || !firstWhiteKey.width) return { totalWidth: 0, handleWidth: 0, trackWidth: 0 };
            const totalWidth = this.WHITE_KEYS_COUNT * firstWhiteKey.width;
            const trackWidth = this.canvas.width;
            const handleWidth = Math.max(20, (trackWidth / totalWidth) * trackWidth);
            return { totalWidth, handleWidth, trackWidth };
        }

        getScrollbarHandleBounds() {
            const { totalWidth, handleWidth, trackWidth } = this.getScrollbarMetrics();
            if (totalWidth <= trackWidth) return { x: 0, y: this.canvas.height - this.SCROLLBAR_HEIGHT, width: 0, height: 0 };
            const maxScroll = totalWidth - trackWidth;
            const maxHandleTravel = trackWidth - handleWidth;
            const handleX = (this.scrollOffset / maxScroll) * maxHandleTravel;
            return { x: handleX, y: this.canvas.height - this.SCROLLBAR_HEIGHT, width: handleWidth, height: this.SCROLLBAR_HEIGHT };
        }

        drawScrollbar() {
            const y = this.canvas.height - this.SCROLLBAR_HEIGHT;
            const trackRadius = 8;
            this.ctx.save();
            this.ctx.fillStyle = '#cccccc';
            this.ctx.beginPath();
            this.ctx.roundRect(0, y, this.canvas.width, this.SCROLLBAR_HEIGHT, trackRadius);
            this.ctx.fill();
            const { totalWidth, handleWidth } = this.getScrollbarMetrics();
            if (totalWidth > this.canvas.width) {
                const handleBounds = this.getScrollbarHandleBounds();
                const handleRadius = 6;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                this.ctx.beginPath();
                this.ctx.roundRect(handleBounds.x + 4, handleBounds.y + 4, handleBounds.width - 8, handleBounds.height - 8, handleRadius);
                this.ctx.fill();
            }
            this.ctx.restore();
        }

        // --- Settings Persistence ---
        saveSettings() {
            try {
                localStorage.setItem(`piano-settings-${this.canvasId}`, JSON.stringify(this.settings));
            } catch (e) { console.error("Could not save settings.", e); }
            this.onSettingsChange(this.settings);
        }

        loadSettings() {
            try {
                const savedSettings = localStorage.getItem(`piano-settings-${this.canvasId}`);
                if (savedSettings) {
                    this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
                    this.updateControlsFromSettings();
                }
            } catch (e) { console.error("Could not load settings.", e); }
        }

        updateControlsFromSettings() {
            this.volumeSlider.value = this.settings.volume;
            this.minVelocitySlider.value = this.settings.minVelocity;
            this.maxVelocitySlider.value = this.settings.maxVelocity;
            this.pitchBendToggle.value = this.settings.pitchBend;
            this.velocityByPosToggle.value = this.settings.velocityByPos;
        }

        updateSettingsFromControls() {
            this.settings.volume = this.volumeSlider.value;
            this.settings.minVelocity = this.minVelocitySlider.value;
            this.settings.maxVelocity = this.maxVelocitySlider.value;
            this.settings.pitchBend = this.pitchBendToggle.value;
            this.settings.velocityByPos = this.velocityByPosToggle.value;
        }
    }

    // --- DEMO APPLICATION ---
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('piano-keyboard-canvas');
        const midiOutputsSelect = document.getElementById('midi-outputs');
        let midiOutput = null;
        let midiAccess = null;

        function sendMidiMessage(message, deviceName = "internal") {
            if (midiOutput) {
                midiOutput.send(message);
            }
        }

        function onSettingsChange(settings) {
            // console.log("Settings changed:", settings);
        }

        const piano = new PianoKeyboard({ 
            canvas: canvas, 
            midiCallback: sendMidiMessage,
            onSettingsChange: onSettingsChange
        });

        function onMidiMessage(event) {
            piano.handleExternalMidiMessage(event.data, event.target.name);
        }

        function setupMidiListeners() {
            if (!midiAccess) return;
            midiAccess.inputs.forEach(input => {
                input.onmidimessage = onMidiMessage;
            });
        }
        
        function updateDeviceLists() {
            if (!midiAccess) return;
            const outputs = midiAccess.outputs.values();
            const selectedOutputId = midiOutputsSelect.value;
            midiOutputsSelect.innerHTML = '';
            let hasOutputs = false;
            for (const output of outputs) {
                const option = document.createElement('option');
                option.value = output.id;
                option.textContent = output.name;
                midiOutputsSelect.appendChild(option);
                hasOutputs = true;
            }
            
            if (!hasOutputs) {
                 midiOutputsSelect.innerHTML = '<option>No MIDI devices found</option>';
                 midiOutput = null;
            } else {
                 // Try to re-select the previously selected device
                 if (midiAccess.outputs.has(selectedOutputId)) {
                    midiOutputsSelect.value = selectedOutputId;
                 }
                 midiOutput = midiAccess.outputs.get(midiOutputsSelect.value);
            }
            setupMidiListeners();
        }

        function onMIDISuccess(ma) {
            midiAccess = ma;
            updateDeviceLists();
            midiAccess.onstatechange = (event) => {
                updateDeviceLists();
            };
        }

        function onMIDIFailure(msg) {
            console.error(`Failed to get MIDI access - ${msg}`);
            midiOutputsSelect.innerHTML = '<option>MIDI Access Failed</option>';
        }

        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess({ sysex: false }).then(onMIDISuccess, onMIDIFailure);
        } else {
            console.warn('WebMIDI is not supported in this browser.');
        }
        
        midiOutputsSelect.addEventListener('change', () => {
            if (midiAccess) {
                midiOutput = midiAccess.outputs.get(midiOutputsSelect.value);
            }
        });
    });

    </script>
</body>
</html>
